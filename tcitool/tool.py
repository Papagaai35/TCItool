"""Author: Daan Gommers"""

import warnings

import numpy as np
import xarray as xr

from tcitool import *

class Tool(object):
    """
    Attributes:
        data: a DataStore containing all atmospheric data points.
    """
    def __init__(self):
        self.data = DataStore()
        self.generator_registry = GeneratorRegistry(self)
        self.calculators = {
            'demo': Calculator,
            'windchill_jagti': WindChill_JAGTICalculator
        }
        self.options = {}
        self._selfassert()

    def _selfassert(self):
        for calc_name, calc in self.calculators.items():
            assert issubclass(calc,Calculator)

    def require_data(self,*args,operation_name=""):
        missing_params = {}
        for param in args:
            if not param in self.data:
                r = self.generator_registry.find_and_run(param)
                if r is None:
                    missing_params[param] = []
                if r is False:
                    missing_params[param] = (
                        self.generator_registry.generators[param])
        if len(missing_params) > 0:
            msg = (
                "The following parameters are nessesary to preform " +
                (operation_name if operation_name=="" else "this operation") +
                ", but unavailable. Some may be generated by the parameters " +
                "indicated\n")
            for mp,gens in missing_params.items():
                msg += '- '+mp
                for gen in gens:
                    gen_missing_params = list(filter(
                        lambda param: param not in self.data,
                        gen['requires']))
                    gen_missing_params += list(map(
                        lambda opt: '[opt]'+opt,
                        filter(lambda opt: opt not in self.options,
                               gen['options'])))
                    msg += '--- '+", ".join(gen_missing_params)
            raise MissingDataError(msg)

    def has_options(self,*args):
        return all(map(lambda opt: opt in self.options,args))

    def calculate(self,*args):
        calculator_objs = {}
        missing_calculators = []
        for calc_name in args:
            if calc_name in self.calculators:
                calc_obj = self.calculators[calc_name](self)
                calc_obj.run()
                calculator_objs[calc_name] = calc_obj
            else:
                missing_calculators.append(calc_name)
                calculator_objs[calc_name] = None
        if len(missing_calculators) > 0:
            warning_msg = ('The calculator(s) [%s] could not be found.\n'
                'Available calculators are [%s].')
            warnings.warn(warning_msg%(",".join(missing_calculators),
                                       ",".join(self.calculators.keys())),
                          UnknownCalculatorWarning)
        return calculator_objs

class GeneratorRegistry(object):
    def __init__(self,tool):
        self.tool = tool
        self.generators = {}
        CommonMeteoGenerators.register_generators(self)

    def register(self,func,provides=None,requires=None,options=None):
        """Registers a callable, that may be used as a generator in this
        GeneratorRegistry

        Args:
            func: callable
            provides: a (list of) string(s), describing the data-keys generated
                by this generator-method
            requires: a (list of) string(s), describing the data-keys needed to
                be able to generate the provides, by this generator-method
            options: a (list of) string(s) describing the options that need to
                be set in the tool, to be able to calculate the provides
        """
        kwargs = {'provides':provides,'requires':requires,'options':options}
        for kwargn in kwargs.keys():
            kwargv = kwargs[kwargn]
            if kwargv is None or (isinstance(kwargv, list) and len(kwargv)==0):
                kwargv = []
            if isinstance(kwargv, str):
                kwargv = [kwargv]
            if not all(map(lambda elem: isinstance(elem,str),provides)):
                raise TypeError("'%s' should be a list of stings"%kwargn)
            kwargs[kwargn] = kwargv

        if not callable(func):
            raise TypeError("'func' should be callable")
        kwargs['func'] = func

        for provides_param in kwargs['provides']:
            if provides_param not in self.generators:
                self.generators[provides_param] = []
            self.generators[provides_param].append(kwargs)

    def find_and_run(self,param):
        """Finds a relevant generator, to satisfy the data need, and runs it.

        Finds a generator, that generates the parameter, where all requirements
        are satisfied (requires and options). If multiple generators exsist, the
        frist generator (in the order of registering) will be used.

        Args:
            param: string describing the data parameter needed.

        Returns:
            True if succeeded
            False if the nessesary `requires` or `options` were not pressent
            None if no generator-method could be found
        """
        if param in self.generators:
            for gen in self.generators[param]:
                if (self.tool.data.has_keys(*gen['requires']) and
                    self.tool.has_options(*gen['options'])):
                    gen['func'](self.tool)
                    return True
            return False
        return None

class CommonMeteoGenerators(object):
    @classmethod
    def register_generators(cls,gr):
        gr.register(cls.t2mC, 't2mC', 't2m')
        gr.register(cls.d2mC, 'd2mC', 'd2m')
        gr.register(cls.sktC, 'sktC', 'skt')
        gr.register(cls.ws10, 'ws10', ['u10','v10'])
        gr.register(cls.wdir10, 'wdir10', ['u10','v10'])

    @classmethod
    def t2mC(cls,tool):
        """Converts the 2m temperature from K to deg C"""
        tool.data['t2mC'] = UnitFuncs.tempK2C(tool.data['t2m'])
        tool.data['t2mC'].attrs['units'] = 'deg C'

    @classmethod
    def d2mC(cls,tool):
        """Converts the 2m dew point from K to deg C"""
        tool.data['d2mC'] = UnitFuncs.tempK2C(tool.data['d2m'])
        tool.data['d2mC'].attrs['units'] = 'deg C'

    @classmethod
    def sktC(cls,tool):
        """Converts the skin temperature from K to deg C"""
        tool.data['sktC'] = UnitFuncs.tempK2C(tool.data['skt'])
        tool.data['sktC'].attrs['units'] = 'deg C'

    @classmethod
    def ws10(cls,tool):
        tool.data['ws10'] = MeteoFuncs.wind_speed(tool.data['u10'],
                                                  tool.data['v10'])
        tool.data['ws10'].attrs['long_name'] = 'Wind speed at 10 metre'
    @classmethod
    def wdir10(cls,tool):
        tool.data['wdir10'] = MeteoFuncs.wind_direction(tool.data['u10'],
                                                        tool.data['v10'])
        tool.data['wdir10'].attrs.update({
            'units': 'rad',
            'long_name': 'Wind direction at 10 metre'
        })
