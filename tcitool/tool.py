"""Author: Daan Gommers"""

import warnings

import numpy as np
import xarray as xr

import tcitool

class Tool(object):
    """
    Attributes:
        data: a DataStore containing all atmospheric data points.
    """
    def __init__(self):
        self.data = DataStore()
        self.generator_registry = GeneratorRegistry(self)
        self.calculators = {
            'demo': Calculator,
            'windchill_jagti': WindChill_JAGTICalculator
        }
        self.options = {}
        self._selfassert()

    def _selfassert(self):
        for calc_name, calc in self.calculators.items():
            assert issubclass(calc,Calculator)

    def require_data(self,*args,operation_name=""):
        missing_params = {}
        for param in args:
            if not param in self.data:
                r = self.generator_registry.find_and_run(param)
                if r is None:
                    missing_params[param] = []
                if r is False:
                    missing_params[param] = (
                        self.generator_registry.generators[param])
        if len(missing_params) > 0:
            msg = (
                "The following parameters are nessesary to preform " +
                (operation_name if operation_name=="" else "this operation") +
                ", but unavailable. Some may be generated by the parameters " +
                "indicated\n")
            for mp,gens in missing_params.items():
                msg += '- '+mp
                for gen in gens:
                    gen_missing_params = list(filter(
                        lambda param: param not in self.data,
                        gen['requires']))
                    gen_missing_params += list(map(
                        lambda opt: '[opt]'+opt,
                        filter(lambda opt: opt not in self.options,
                               gen['options'])))
                    msg += '--- '+", ".join(gen_missing_params)
            raise MissingDataError(msg)

    def has_options(self,*args):
        return all(map(lambda opt: opt in self.options,args))

    def calculate(self,*args):
        calculator_objs = {}
        missing_calculators = []
        for calc_name in args:
            if calc_name in self.calculators:
                calc_obj = self.calculators[calc_name](self)
                calc_obj.run()
                calculator_objs[calc_name] = calc_obj
            else:
                missing_calculators.append(calc_name)
                calculator_objs[calc_name] = None
        if len(missing_calculators) > 0:
            warning_msg = ('The calculator(s) [%s] could not be found.\n'
                'Available calculators are [%s].')
            warnings.warn(warning_msg%(",".join(missing_calculators),
                                       ",".join(self.calculators.keys())),
                          UnknownCalculatorWarning)
        return calculator_objs

class Calculator(object):
    """A calculator calculates a thermal comfort index.

    A calculator calculates a thermal comfort index, and may use Generators, and
    Functions to do that calculation. Calculators need to be registerd in the
    main-class (Tool), and need to implement this function.

    Attributes:
        tool: reference to the tool used
        data: the datastore of this calculator
        name: name of the class
        export_params: a dict[(str,str)] of parameters that will be exported to
            the DataStore of tool (tool.data). Keys indicate local names, values
            names after export.
    """
    def __init__(self,tool):
        self.tool = tool
        self.data = tool.data.copy_empty()
        self.name = self.__class__.__name__
        self.export_params = {}

    def require_data(self,*args):
        self.tool.require_data(*args,operation_name=self.name)

    def export(self):
        params = list(self.export_params.keys())
        self.tool.data.merge(
            self.data[params].rename_vars(**self.export_params)
        )

    def run(self):
        self.main()
        self.export()

    def main(self):
        raise NotImplementedError()

class WindChill_JAGTICalculator(Calculator):
    def __init__(self,tool):
        super().__init__(tool)
        self.export_params = {'wcet':'wcet_jagti'}
        self.require_data('t2m','ws10')

    def main(self):
        t2mC = self.tool.data.get('t2m',UnitFuncs.tempK2C(self.tool.data['t2m']))
        wind_at_15dm = (3.6*self.tool.data['ws10'])**0.16
        wcet = 13.12 + 0.6215 * t2mC \
                     - 11.37 * wind_at_15dm \
                     + 0.3965 * t2mC * wind_at_15dm
        wcet.attrs.update({
            'units': 'deg C',
            'long_name': 'Wind Chill Equivalent Temperature (using JAG/TI '
                'calculation method)',
            'source': 'Eq. 2.3 in https://cdn.knmi.nl/system/downloads/files/000/000/016/original/gevoelstemperatuur.pdf?1433939065'
        })
        self.data['wcet'] = wcet

class DataStore(object):
    def __init__(self,file_or_xarray=None,**kwargs):
        """Inits this DataStore

        Args:
            filename_or_xarray: A file path describing the location of the file
            to be loaded (if string), or a xarray.Dataset containing the data.
            **kwargs: will be passed to xarray.open_dataset
        """
        self._ds = None
        if file_or_xarray is not None:
            self.load(file_or_xarray,**kwargs)

    def ds():
        doc = "The xarray.Dataset containing the data"
        def fget(self):
            if self._ds is None:
                raise ValueError("ds has not been set yet.")
            return self._ds
        def fset(self, value):
            if not isinstance(value, xr.Dataset):
                raise TypeError("You may only set ds with a xarray.Dataset")
            self._ds = value
        return locals()
    ds = property(**ds())

    def __getitem__(self,*args,**kwargs):
        """Alias for xarray.Dataset.__getitem__"""
        return self.ds.__getitem__(*args,**kwargs)

    def __setitem__(self,*args,**kwargs):
        """Alias for xarray.Dataset.__setitem__"""
        return self.ds.__setitem__(*args,**kwargs)

    def __delitem__(self,*args,**kwargs):
        """Alias for xarray.Dataset.__delitem__"""
        return self.ds.__delitem__(*args,**kwargs)

    def __contains__(self,*args,**kwargs):
        """Alias for xarray.Dataset.__contains__"""
        return self.ds.__contains__(*args,**kwargs)

    def get(self,key,default):
        return self.ds[key] if key in self else default

    def load(self,file_or_xarray,**kwargs):
        """Loads data form a xarray or file

        Args:
            filename_or_xarray: A file path describing the location of the file
            to be loaded (if string), or a xarray.Dataset containing the data.
            **kwargs: will be passed to xarray.open_dataset
        """
        self.ds = ( file_or_xarray
                    if isinstance(file_or_xarray, xr.Dataset)
                    else xr.open_dataset(file_or_xarray,**kwargs))

    def save(self,filepath,**kwargs):
        kwargs.update({'path':filepath})
        self.ds.to_netcdf(**kwargs)

    def buffer(self,filepath,save_kwargs=None,load_kwargs=None):
        if save_kwargs is None:
            save_kwargs = {}
        if not isinstance(save_kwargs,dict):
            raise TypeError("'save_kwargs' must be a dictionary")
        if load_kwargs is None:
            load_kwargs = {}
        if not isinstance(load_kwargs,dict):
            raise TypeError("'load_kwargs' must be a dictionary")

        self.save(filepath,**save_kwargs)
        self.load(filepath,**save_kwargs)

    def merge(self,datastore_or_xarray):
        """Merge with an other DataStore or xarray.Dataset"""
        if isinstance(datastore_or_xarray,DataStore):
            self.ds = xr.merge([self.ds,datastore_or_xarray.ds])
        elif isinstance(datastore_or_xarray,xr.Dataset):
            self.ds = xr.merge([self.ds,datastore_or_xarray])
        else:
            raise TypeError("datastore_or_xarray must be a DataStore or "
                            "xarray.Dataset")

    def copy_empty(self):
        return self.ds.coords.to_dataset()

    def has_keys(self,*args):
        return all(map(lambda param: param in self.ds,args))

class GeneratorRegistry(object):
    def __init__(self,tool):
        self.tool = tool
        self.generators = {}
        CommonMeteoGenerators.register_generators(self)

    def register(self,func,provides=None,requires=None,options=None):
        """Registers a callable, that may be used as a generator in this
        GeneratorRegistry

        Args:
            func: callable
            provides: a (list of) string(s), describing the data-keys generated
                by this generator-method
            requires: a (list of) string(s), describing the data-keys needed to
                be able to generate the provides, by this generator-method
            options: a (list of) string(s) describing the options that need to
                be set in the tool, to be able to calculate the provides
        """
        kwargs = {'provides':provides,'requires':requires,'options':options}
        for kwargn in kwargs.keys():
            kwargv = kwargs[kwargn]
            if kwargv is None or (isinstance(kwargv, list) and len(kwargv)==0):
                kwargv = []
            if isinstance(kwargv, str):
                kwargv = [kwargv]
            if not all(map(lambda elem: isinstance(elem,str),provides)):
                raise TypeError("'%s' should be a list of stings"%kwargn)
            kwargs[kwargn] = kwargv

        if not callable(func):
            raise TypeError("'func' should be callable")
        kwargs['func'] = func

        for provides_param in kwargs['provides']:
            if provides_param not in self.generators:
                self.generators[provides_param] = []
            self.generators[provides_param].append(kwargs)

    def find_and_run(self,param):
        """Finds a relevant generator, to satisfy the data need, and runs it.

        Finds a generator, that generates the parameter, where all requirements
        are satisfied (requires and options). If multiple generators exsist, the
        frist generator (in the order of registering) will be used.

        Args:
            param: string describing the data parameter needed.

        Returns:
            True if succeeded
            False if the nessesary `requires` or `options` were not pressent
            None if no generator-method could be found
        """
        if param in self.generators:
            for gen in self.generators[param]:
                if (self.tool.data.has_keys(*gen['requires']) and
                    self.tool.has_options(*gen['options'])):
                    gen['func'](self.tool)
                    return True
            return False
        return None

class CommonMeteoGenerators(object):
    @classmethod
    def register_generators(cls,gr):
        gr.register(cls.t2mC, 't2mC', 't2m')
        gr.register(cls.d2mC, 'd2mC', 'd2m')
        gr.register(cls.sktC, 'sktC', 'skt')
        gr.register(cls.ws10, 'ws10', ['u10','v10'])
        gr.register(cls.wdir10, 'wdir10', ['u10','v10'])

    @classmethod
    def t2mC(cls,tool):
        """Converts the 2m temperature from K to deg C"""
        tool.data['t2mC'] = UnitFuncs.tempK2C(tool.data['t2m'])
        tool.data['t2mC'].attrs['units'] = 'deg C'

    @classmethod
    def d2mC(cls,tool):
        """Converts the 2m dew point from K to deg C"""
        tool.data['d2mC'] = UnitFuncs.tempK2C(tool.data['d2m'])
        tool.data['d2mC'].attrs['units'] = 'deg C'

    @classmethod
    def sktC(cls,tool):
        """Converts the skin temperature from K to deg C"""
        tool.data['sktC'] = UnitFuncs.tempK2C(tool.data['skt'])
        tool.data['sktC'].attrs['units'] = 'deg C'

    @classmethod
    def ws10(cls,tool):
        tool.data['ws10'] = MeteoFuncs.wind_speed(tool.data['u10'],
                                                  tool.data['v10'])
        tool.data['ws10'].attrs['long_name'] = 'Wind speed at 10 metre'
    @classmethod
    def wdir10(cls,tool):
        tool.data['wdir10'] = MeteoFuncs.wind_direction(tool.data['u10'],
                                                        tool.data['v10'])
        tool.data['wdir10'].attrs.update({
            'units': 'rad',
            'long_name': 'Wind direction at 10 metre'
        })

class UnitFuncs(object):
    @classmethod
    def dms2deg(cls,d,m,s):
        """Converts a degree,minute,seconds to decimal degrees"""
        return d+m/60+s/3600
    @classmethod
    def dms2rad(cls,d,m,s):
        """Converts a degree,minute,seconds to radians"""
        return np.deg2rad(cls.dms2deg(d,m,s))
    @classmethod
    def tempC2K(cls,temp_C):
        """Converts a temperature in Celcius to Kelvin"""
        return temp_C + 273.15
    @classmethod
    def tempK2C(cls,temp_K):
        """Converts a temperature in Kelvin to Celcius"""
        return temp_K - 273.15

class MeteoFuncs(object):
    @classmethod
    def wind_speed(cls,u,v):
        """Caluclates the wind speed from U and V components"""
        return np.sqrt(np.power(u,2)+np.power(v,2))
    @classmethod
    def wind_direction(cls,u,v):
        """Caluclates the wind direction from U and V components"""
        return np.deg2rad(180+180/np.pi*np.arctan2(u,v))
